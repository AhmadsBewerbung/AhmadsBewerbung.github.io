<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cartoony Orb Collector — Fun Addicting Game</title>
  <style>
    :root{
      --bg:#fbeff2;
      --panel:#fff;
      --accent:#ff6b6b;
      --accent2:#ffd166;
      --muted:#6b6b6b;
      --glass: rgba(255,255,255,0.7);
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:linear-gradient(180deg,var(--bg),#fff); color:#222}
    .wrap{max-width:1100px;margin:20px auto;padding:18px}
    header{display:flex;align-items:center;gap:14px}
    h1{margin:0;font-size:22px;letter-spacing:0.5px}
    .sub{color:var(--muted);font-size:13px}

    /* Game area */
    .game-area{display:grid;grid-template-columns:1fr 320px;gap:16px;margin-top:16px}
    .stage{background:linear-gradient(180deg,#e8f7ff,#f7fbff);border-radius:18px;padding:12px;box-shadow:0 10px 30px rgba(80,90,120,0.06);position:relative}
    canvas{width:100%;height:600px;border-radius:12px;background:linear-gradient(180deg,#bfe9ff,#fdfdff);display:block}

    /* Right panel */
    .panel{background:var(--panel);border-radius:12px;padding:12px;box-shadow:0 6px 20px rgba(60,70,90,0.06);display:flex;flex-direction:column;gap:12px}
    .score{font-weight:700;font-size:18px;color:var(--accent)}
    .big{font-size:40px;color:var(--accent2);font-weight:800;line-height:1}
    .controls{display:flex;gap:8px}
    button{cursor:pointer;border:0;padding:10px 12px;border-radius:10px;background:linear-gradient(180deg,#fff,#eee);box-shadow:0 6px 18px rgba(0,0,0,0.06);font-weight:700}
    .primary{background:linear-gradient(180deg,var(--accent),#ff4b4b);color:white}
    .muted{background:linear-gradient(180deg,#fafafa,#f3f3f3);color:var(--muted)}

    .tip{font-size:13px;color:#444;background:linear-gradient(180deg,#fff8e6,#fff);padding:8px;border-radius:8px}
    footer{margin-top:14px;color:var(--muted);font-size:12px}

    /* Responsive */
    @media (max-width:900px){
      .game-area{grid-template-columns:1fr;}
      canvas{height:480px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <img src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='44' height='44'><rect rx='10' width='44' height='44' fill='%23ffd166'/><circle cx='22' cy='18' r='10' fill='%23ff6b6b'/><circle cx='26' cy='14' r='2' fill='white'/></svg>" alt="logo" style="width:44px;height:44px;">
      <div>
        <h1>Cartoony Orb Collector</h1>
        <div class="sub">Collect colorful orbs, chain combos, and beat your high score. Click / tap to move — it's simple, but addicting!</div>
      </div>
    </header>

    <div class="game-area">
      <section class="stage">
        <canvas id="game" width="800" height="600" aria-label="Cartoony Orb Collector game canvas"></canvas>
        <div id="overlay" style="position:absolute;left:12px;top:12px;pointer-events:none"></div>
      </section>

      <aside class="panel" aria-hidden="false">
        <div>
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div>
              <div class="score">Score</div>
              <div class="big" id="score">0</div>
            </div>
            <div style="text-align:right">
              <div style="font-size:12px;color:var(--muted)">High</div>
              <div id="high" style="font-weight:800;font-size:18px">0</div>
            </div>
          </div>
        </div>

        <div class="tip">
          How to play: Move the cursor or touch to pull your bouncy buddy. Collect orbs for points. Avoid black bombs. Blue orbs give slow-mo, yellow gives score-multiplier.
        </div>

        <div style="display:flex;gap:8px;align-items:center;justify-content:space-between">
          <div class="controls">
            <button id="start" class="primary">Start</button>
            <button id="pause" class="muted">Pause</button>
            <button id="reset" class="muted">Reset</button>
          </div>
        </div>

        <div>
          <div style="font-weight:700;margin-bottom:6px">Power-ups</div>
          <div style="display:flex;gap:8px">
            <div style="flex:1;padding:8px;border-radius:8px;background:linear-gradient(180deg,#fff,#fbfbfb);text-align:center">Slow-mo <br><small class="sub">Blue orb</small></div>
            <div style="flex:1;padding:8px;border-radius:8px;background:linear-gradient(180deg,#fff,#fbfbfb);text-align:center">x2 <br><small class="sub">Yellow orb</small></div>
          </div>
        </div>

        <div style="margin-top:auto">
          <div style="font-size:12px;color:var(--muted);margin-bottom:6px">Controls: Mouse / Touch to move, Space to dash</div>
          <div style="display:flex;gap:8px">
            <button id="share" class="muted">Share Score</button>
            <button id="sound" class="muted">Toggle Sound</button>
          </div>
        </div>

      </aside>
    </div>

    <footer>Built with ❤️ — single-file HTML. High scores saved locally.</footer>
  </div>

  <script>
  // Cartoony Orb Collector — single-file game
  // Features:
  // - Canvas rendering with cute shapes
  // - Mouse/touch input, keyboard dash (Space)
  // - Orbs with different behavior (score, slow-mo, multiplier)
  // - Bombs to avoid (end combo)
  // - Particles and sound (WebAudio synth)
  // - High score in localStorage
  // - Responsive and accessible basic UI

  (()=>{
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let W = canvas.width, H = canvas.height;

    // HiDPI support
    function resizeCanvas(){
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.max(320, Math.floor(rect.width * dpr));
      canvas.height = Math.max(240, Math.floor(rect.height * dpr));
      W = canvas.width; H = canvas.height;
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Audio helper (simple cute blips)
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let soundOn = true;
    function blip(freq=440, type='sine', time=0.05, gain=0.08){
      if(!soundOn) return;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type; o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g); g.connect(audioCtx.destination);
      o.start();
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + time);
      o.stop(audioCtx.currentTime + time + 0.02);
    }

    // Persistent high score
    const KEY = 'cartoony_orb_highscore_v1';
    let high = parseInt(localStorage.getItem(KEY) || '0',10);
    document.getElementById('high').textContent = high;

    // Game state
    let running=false, paused=false;
    let score=0; let multiplier=1; let combo=0; let speedScale=1;
    const orbs = []; const bombs=[]; const particles = [];
    const MAX_ORBS = 8;
    let lastSpawn = 0; let spawnInterval = 1000; // ms

    // Player (a bouncy blob)
    const player = {
      x: W/2, y: H/2, r: 28, vx:0, vy:0, color:'#ff6b6b', drag:0.92
    };

    // Input
    const input = {x:player.x, y:player.y, active:false};
    function setPointer(x,y){ input.x = x; input.y = y; }
    canvas.addEventListener('pointerdown', e=>{ input.active=true; setPointer(e.offsetX, e.offsetY); if(!running) startGame(); });
    canvas.addEventListener('pointermove', e=>{ if(input.active) setPointer(e.offsetX, e.offsetY); });
    window.addEventListener('pointerup', ()=> input.active=false);

    // Keyboard
    window.addEventListener('keydown', (e)=>{
      if(e.code==='Space'){ e.preventDefault(); dash(); }
      if(e.code==='KeyP'){ togglePause(); }
    });

    // UI buttons
    document.getElementById('start').addEventListener('click', ()=> startGame());
    document.getElementById('pause').addEventListener('click', ()=> togglePause());
    document.getElementById('reset').addEventListener('click', ()=> resetGame());
    document.getElementById('sound').addEventListener('click', ()=>{ soundOn=!soundOn; blip(880,'square',0.03,0.05); document.getElementById('sound').textContent = soundOn ? 'Sound: On' : 'Sound: Off';});
    document.getElementById('share').addEventListener('click', ()=>{ navigator.clipboard?.writeText(`I scored ${score} in Cartoony Orb Collector!`).then(()=>alert('Score copied to clipboard!')) });

    // Spawn helpers
    function rand(min,max){ return Math.random()*(max-min)+min; }
    function choose(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

    // Create orb
    function spawnOrb(){
      const side = Math.random();
      let x = rand(60, W-60), y = rand(60, H-60);
      // ensure away from player
      if(Math.hypot(x-player.x,y-player.y) < 120){ x = (x + 180) % (W-60) + 30; }
      // types: red=normal, blue=slow, yellow=mult
      const types = ['red','red','red','blue','yellow'];
      const type = choose(types);
      const orb = {x,y,r: rand(12,20), type, angle: rand(0,Math.PI*2), wob:rand(0.5,1.6)};
      orbs.push(orb);
    }
    function spawnBomb(){
      const x = rand(40,W-40), y = rand(40,H-40);
      bombs.push({x,y,r:18, vx:rand(-1.2,1.2), vy:rand(-1.2,1.2), wob:0});
    }

    // Particles
    function emit(x,y,color,count=8){
      for(let i=0;i<count;i++){
        particles.push({x,y, vx:Math.cos(Math.random()*Math.PI*2)*rand(1,4), vy:Math.sin(Math.random()*Math.PI*2)*rand(1,4), life:rand(40,90), age:0, color, r:rand(2,5)});
      }
    }

    // Dash (temporary burst)
    let dashTimer=0;
    function dash(){ dashTimer = 12; blip(900,'sawtooth',0.06,0.06); }

    // Game control
    function startGame(){ if(running) return; running=true; paused=false; score=0; multiplier=1; combo=0; speedScale=1; orbs.length=0; bombs.length=0; particles.length=0; player.x = W/2; player.y = H/2; player.vx=player.vy=0; lastSpawn=0; spawnInterval=900; document.getElementById('score').textContent = score; loop(performance.now()); blip(600,'sine',0.08,0.08); }
    function resetGame(){ localStorage.removeItem(KEY); high=0; document.getElementById('high').textContent = high; resetRound(); }
    function resetRound(){ running=false; paused=false; orbs.length=0; bombs.length=0; particles.length=0; score=0; combo=0; multiplier=1; document.getElementById('score').textContent = score; }
    function togglePause(){ if(!running) return; paused = !paused; document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause'; if(!paused) loop(performance.now()); }

    // Collision helpers
    function circleDist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }

    // Game loop
    let lastTime = 0;
    function loop(t){ if(!running) return; if(paused) return; const dt = Math.min(40, t-lastTime); lastTime = t;
      update(dt/16.666); render(); requestAnimationFrame(loop);
    }

    function update(delta){
      // Input attracts player like spring
      if(input.active){
        const dx = input.x - player.x; const dy = input.y - player.y;
        player.vx += dx*0.02*delta; player.vy += dy*0.02*delta;
      } else {
        // gentle float
        player.vx += Math.sin(performance.now()/1000 + player.x)*0.0002*delta;
      }

      // dash!
      if(dashTimer>0){ player.vx *= 1.04; player.vy *= 1.04; dashTimer--; }

      // physics
      player.vx *= player.drag; player.vy *= player.drag;
      player.x += player.vx * delta * (1+speedScale*0.2);
      player.y += player.vy * delta * (1+speedScale*0.2);
      // clamp
      player.x = Math.max(player.r, Math.min((W/playerScale())-player.r, player.x));
      player.y = Math.max(player.r, Math.min((H/playerScale())-player.r, player.y));

      // spawn logic
      lastSpawn += delta * 16.666;
      if(lastSpawn > spawnInterval){ lastSpawn = 0; spawnOrb(); if(Math.random()<0.12) spawnBomb(); spawnInterval = Math.max(350, spawnInterval - 10); }
      while(orbs.length > MAX_ORBS) orbs.shift();

      // orbs wobble
      for(const o of orbs){ o.angle += 0.02*o.wob*delta; o.x += Math.cos(o.angle)*0.02*delta; o.y += Math.sin(o.angle)*0.02*delta; }

      // bombs move
      for(const b of bombs){ b.vx *= 0.995; b.vy *= 0.995; b.x += b.vx * delta; b.y += b.vy * delta; if(b.x < b.r || b.x > W-b.r) b.vx *= -1; if(b.y < b.r || b.y > H-b.r) b.vy *= -1; }

      // collisions
      for(let i=orbs.length-1;i>=0;i--){ const o = orbs[i]; const d = Math.hypot(o.x-player.x, o.y-player.y); if(d < o.r + player.r){ collectOrb(o); orbs.splice(i,1); } }
      for(let i=bombs.length-1;i>=0;i--){ const b = bombs[i]; const d = Math.hypot(b.x-player.x, b.y-player.y); if(d < b.r + player.r - 6){ hitBomb(b); bombs.splice(i,1); } }

      // particles update
      for(let i=particles.length-1;i>=0;i--){ const p = particles[i]; p.vy += 0.06*delta; p.x += p.vx*delta; p.y += p.vy*delta; p.age += delta; if(p.age > p.life) particles.splice(i,1); }

      // slowly decay multiplier
      if(multiplier > 1){ multiplier = Math.max(1, multiplier - 0.002*delta); }

      // UI update
      document.getElementById('score').textContent = Math.floor(score);
    }

    function playerScale(){ return 1; }

    function collectOrb(o){
      // effects
      emit(o.x, o.y, o.type === 'blue' ? '#6fb3ff' : o.type === 'yellow' ? '#ffd166' : '#ff6b6b', 14);
      if(o.type === 'blue'){ speedScale = Math.max(0.6, speedScale - 0.35); blip(540,'sine',0.08,0.06);
        // temporary slow-mo effect
        setTimeout(()=>{ speedScale = Math.min(1.2, speedScale + 0.4); }, 1200);
      } else if(o.type === 'yellow'){ multiplier = Math.min(4, multiplier + 1.0); blip(1100,'triangle',0.08,0.08); }
      else { blip(720 + Math.random()*200,'sine',0.06,0.06); }

      // scoring and combo
      combo++; const base = 10 + o.r; const gained = base * multiplier * (1 + Math.min(1.5, combo/10));
      score += gained;
      // small pop animation on player
      player.r = Math.min(46, player.r + 2 + o.r*0.08);
      setTimeout(()=>{ player.r = 28; }, 120);

      // rewards: sometimes spawn extra orbs
      if(Math.random() < 0.15) spawnOrb();
      if(Math.random() < 0.06) spawnBomb();

      // increase difficulty slowly
      spawnInterval = Math.max(350, spawnInterval - 8);

      // update high score
      if(score > high){ high = Math.floor(score); localStorage.setItem(KEY, high); document.getElementById('high').textContent = high; }
    }

    function hitBomb(b){
      // explode
      emit(b.x, b.y, '#222', 28);
      blip(140,'sawtooth',0.24,0.14);
      // penalty
      combo = 0; multiplier = Math.max(1, multiplier - 1); score = Math.max(0, score - 40);
      // tiny screen shake achieved by jiggling player
      player.vx += (Math.random()-0.5)*6; player.vy += (Math.random()-0.5)*6;
    }

    // Render UI
    function render(){
      // clear
      ctx.clearRect(0,0,W,H);
      // background silly clouds
      renderBackground();

      // orbs
      for(const o of orbs){ drawOrb(o); }
      // bombs
      for(const b of bombs){ drawBomb(b); }

      // particles
      for(const p of particles){ ctx.globalAlpha = 1 - (p.age/p.life); round(p.x,p.y,p.r,p.color); }
      ctx.globalAlpha = 1;

      // player (cute blob)
      drawPlayer(player);

      // HUD overlay (combo / multiplier)
      ctx.font = '14px system-ui, Arial'; ctx.fillStyle = '#444';
      ctx.fillText(`Combo: ${combo}`, 14, 20);
      ctx.fillText(`x${multiplier.toFixed(1)}`, 14, 40);
    }

    function renderBackground(){
      // soft radial gradient
      const g = ctx.createLinearGradient(0,0,0,H);
      g.addColorStop(0,'#f8feff'); g.addColorStop(1,'#e9f8ff');
      ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
      // drifting clouds
      const t = performance.now()/7000;
      for(let i=0;i<5;i++){
        const cx = (Math.sin(t + i)*0.5 + 0.5) * W;
        const cy = 40 + i*60;
        ctx.globalAlpha = 0.12;
        drawCloud(cx, cy, 60 + Math.sin(t+i)*12);
        ctx.globalAlpha = 1;
      }
    }

    function drawCloud(x,y,size){
      ctx.beginPath(); ctx.fillStyle = '#ffffff';
      ctx.ellipse(x,y,size*0.6,size*0.36,0,0,Math.PI*2);
      ctx.ellipse(x-size*0.4,y+6,size*0.5,size*0.28,0,0,Math.PI*2);
      ctx.ellipse(x+size*0.45,y+4,size*0.45,size*0.26,0,0,Math.PI*2);
      ctx.fill();
    }

    function drawOrb(o){
      const grd = ctx.createRadialGradient(o.x-4,o.y-4,o.r*0.1,o.x,o.y,o.r);
      if(o.type==='blue'){ grd.addColorStop(0,'#9fd9ff'); grd.addColorStop(1,'#6fb3ff'); }
      else if(o.type==='yellow'){ grd.addColorStop(0,'#fff2be'); grd.addColorStop(1,'#ffd166'); }
      else { grd.addColorStop(0,'#ffb2b2'); grd.addColorStop(1,'#ff6b6b'); }
      ctx.fillStyle = grd; round(o.x, o.y, o.r);
      // highlight
      ctx.globalCompositeOperation = 'lighter';
      ctx.beginPath(); ctx.ellipse(o.x - o.r*0.35, o.y - o.r*0.45, o.r*0.45, o.r*0.25, 0,0,Math.PI*2); ctx.fillStyle='rgba(255,255,255,0.35)'; ctx.fill();
      ctx.globalCompositeOperation = 'source-over';
    }

    function drawBomb(b){
      // body
      ctx.beginPath(); ctx.fillStyle = '#222'; round(b.x,b.y,b.r);
      // shine
      ctx.beginPath(); ctx.ellipse(b.x - b.r*0.35, b.y - b.r*0.35, b.r*0.5, b.r*0.35, 0,0,Math.PI*2); ctx.fillStyle='rgba(255,255,255,0.06)'; ctx.fill();
      // fuse
      ctx.strokeStyle = '#333'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(b.x + b.r*0.6, b.y - b.r*0.6); ctx.lineTo(b.x + b.r*1.1, b.y - b.r*1.1); ctx.stroke();
      // spark
      ctx.beginPath(); ctx.fillStyle = '#ffcc33'; ctx.ellipse(b.x + b.r*1.12, b.y - b.r*1.12, 6,4,0,0,Math.PI*2); ctx.fill();
    }

    function drawPlayer(p){
      // shadow
      ctx.beginPath(); ctx.fillStyle = 'rgba(30,30,30,0.08)'; ctx.ellipse(p.x, p.y + p.r*0.9, p.r*0.9, p.r*0.28, 0,0,Math.PI*2); ctx.fill();
      // main blob with subtle gradient
      const g = ctx.createRadialGradient(p.x - p.r*0.2, p.y - p.r*0.3, 4, p.x, p.y, p.r*1.2);
      g.addColorStop(0, '#ffd0d0'); g.addColorStop(0.6, '#ff9b9b'); g.addColorStop(1, '#ff6b6b');
      ctx.fillStyle = g; round(p.x, p.y, p.r);
      // eyes
      ctx.beginPath(); ctx.fillStyle='white'; ctx.ellipse(p.x - p.r*0.25, p.y - p.r*0.08, p.r*0.28, p.r*0.34, 0,0,Math.PI*2); ctx.ellipse(p.x + p.r*0.18, p.y - p.r*0.06, p.r*0.22, p.r*0.28, 0,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.fillStyle='#2b2b2b'; ctx.ellipse(p.x - p.r*0.18, p.y - p.r*0.02, p.r*0.10, p.r*0.14, 0,0,Math.PI*2); ctx.ellipse(p.x + p.r*0.22, p.y - p.r*0.02, p.r*0.10, p.r*0.14, 0,0,Math.PI*2); ctx.fill();
      // smile
      ctx.beginPath(); ctx.strokeStyle='rgba(0,0,0,0.22)'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(p.x, p.y + p.r*0.06, p.r*0.4, 0.28*Math.PI, 0.72*Math.PI); ctx.stroke();
    }

    function round(x,y,r,color){ if(color) ctx.fillStyle = color; ctx.beginPath(); ctx.ellipse(x,y,r,r,0,0,Math.PI*2); ctx.fill(); }

    // initial gentle spawn
    for(let i=0;i<4;i++) spawnOrb(); spawnBomb();

    // initial render frame
    render();

    // small autoplay hint
    setTimeout(()=>{ if(!running){ ctx.save(); ctx.globalAlpha=0.9; ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.fillRect(W/2-120, H/2-36, 240,72); ctx.fillStyle='#444'; ctx.font='16px system-ui, Arial'; ctx.fillText('Click or tap to start', W/2-80, H/2); ctx.restore(); } }, 700);

  })();
  </script>
</body>
</html>
